# С++.
С - плохо читаемый язык, и больше программы на нем было очень сложно разобрать. Но он был очень быстрым и это послужило началом разработки языка С++.
## Инкапсуляция
 Для поддержки процесса данных в плюсах есть 2 механизма:
[`(*p).data == p->data`]
```c++
struct string 
{
	void clear()
	{	
		if (data)
			free(data);
		data = nullptr;
		size = 0;
	}
private:
	char * data;
	size_t size;
};
```
Инвариант класса - условие выполняющееся на всех этапах существования класса.
Хорошее условие: 

> Все переменные, от которых зависит инвариант класса должны быть `private` 

Но иногда может понадобиться модификатор private и для других переменных:
```c++
struct complex 
{
	float re;
	float im;
};
```
Полярные координаты в комплексных числах, а мы хотим иметь возможность менять КС и переходить между ними. 
В стандартной библиотеке класс `complex` имеет `private` переменные.  
## Ключевые слова class и struct
Они отличаются только тем, что в `struct` все по умолчанию `public`, а в `class` - `private`
## Конструкторы и деструкторы
Нам важно что при создании класса его инфариант мог бы быть выполненным. Для этого нужны конструкторы:
```c++
	string()
	{
		data = nullptr;
		size = 0;
		capacity = 0;
	}
	string(char const* p)
	{
		data = ...
	}
```
Так же существуют деструкторы, освобождающие память при не использовании объекта. Они вызываются когда объект выходит из "зоны видимости":
```c++
	~string()
	{
		free(data);
		...
	}
```
Задача конструктора в том, чтобы сделать инвариант выполняющимся при условно неверных входных данных. Деструктор работает по обратному принципу.
## Операторы
В С++ есть возможность определять собственные операторы для классов:
```c++
complex operator+(complex a, complex b)
{
	return complex(a.re + b.re, a.im + a.im)
}
```
Если вы пишете какой то оператор, то хотя бы 1 из его элементов должен быть пользовательским типом (нельзя переопределить оператор для `int, int`)
Еще пример:
```c++
complex operator+=(complex a, complex b) {}
```
Мы такое сделать не можем, т.к. нужно поменять а => передать его по указателю. `&a += b`, что не естественно.
Сделать такое можно через чит, который называется "ссылка":


|указатель		|	ссылка			|
|---------------|-------------------|
|`int* p = &a;`	|	`int& r = a;`	|
|`*p = 5;`		|	`r = 5;`		|
|`int *pp = p`	|	`int* pr = &r;`	|
|`p = &b;`		|	`//такого нет`	|
Если мы сделаем вот так:
```c++
complex& operator+=(complex &a, complex b)
{
	return complex(a.re + b.re, a.im + a.im)
}
```
То все будет окей.
## [rvalue и lvalue](https://habrahabr.ru/post/348198/)
(извените проебал... ссылка на хабр)
## const
Ключевое слово `const` - неизменяемое.
```c++
	int const PI = 3;
	int const* q = &PI; 
	//int *q = &PI; - кинет ошибку
	*q = 4;
	
	int		 *		 a; - изм указатель на изм
	int	const*		 b; - изм ууказатель на неизм
	int		 * const b; - неизм указатель на изм
	int const* const c; - неизм указатель на неизм

	int const & a; - неизм
```
----------
# Следующая лекция
(блэт)
## new и delete
Дорогие операции. 
Отличие `new-delete` от `malloc-free`
`new` - вызов `malloc`'a а на этой памяти вызов конструктора
`delete` - наоборот по сути, сначала деструктор потом `free`
```c++
//хуйня:
foo* p = new foo[2];
delete[] p;
//норм:
vector <foo> p(2);
```
> Written with [StackEdit](https://stackedit.io/).

